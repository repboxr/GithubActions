
#' Set personal access token by writing it into environment variables.
#'
#' @param pat A string containing the personal access token generated on Github.
#'
#' Not very secure. At some point I should use the approach of the gh package
gh_set_pat = function(pat) {
  # Used by these API functions
  Sys.setenv(GITHUB_PAT = pat)

  # Used by github cli
  Sys.setenv(GITHUB_TOKEN = pat)

}

#' Get personal access token that was previously set b gh_set_pat.
gh_pat = function() {
  Sys.getenv("GITHUB_PAT")
}

#' Wait until a new Github action job has started
gh_wait_until_new_run_starts = function(repo, old_runid, pause.sec = 1, timeout = 60, pat=gh_pat()) {
  start.time = Sys.time()

  seconds_passed(start.time)

  while(TRUE) {
    runs = gh_list_runs(repo, pat)
    if (NROW(runs)>0) {
      if (is.null(old_runid)) {
        return(runs$id[[1]])
      }
      if (runs$id[[1]] != old_runid) {
        return(runs$id[[1]])
      }
    }
    # timeout
    if (seconds_passed(start.time) > timeout) {
      return(NA)
    }
    Sys.sleep(pause.sec)
  }

}

#' Wait until a new Github action job is completed
gh_wait_until_run_completed = function(repo, runid, pause.sec = 1, timeout = 60*60*10, pat=gh_pat()) {
  restore.point("gh_waint_until_run_completed")
  start.time = Sys.time()

  seconds_passed(start.time)

  while(TRUE) {
    run = try(gh_info_run(repo,runid, pat),silent = TRUE)
    if (is(run, "try-error")) {
      cat(paste0(Sys.time()," problem while retrieving status of GHA run:\n", paste0(as.character(run), collapse="\n"),"\nWill try again..."))
      Sys.sleep(pause.sec)
      next
    }
    if (is.null(run)) {
      # Run with given id does not exist
      return(NULL)
    }
    if (run$status == "completed") {
      run$timeout = FALSE
      return(run)
    }
    # timeout
    if (seconds_passed(start.time) > timeout) {
      run$timeout = TRUE
      return(run)
    }
    Sys.sleep(pause.sec)
  }
}


#' Show all jobs of a run. Some functions require the corresponding job id.
gh_list_run_jobs = function(repo, runid, pat=gh_pat()) {
  #https://api.github.com/repos/OWNER/REPO/actions/runs/RUN_ID/jobs
  gh_get(paste0("repos/", repo,"/actions/runs/",runid,"/jobs"),pat)$jobs
}

#' Info about a workflow run.
gh_info_run = function(repo, runid, pat = gh_pat()) {
  #  https://api.github.com/repos/OWNER/REPO/actions/runs/RUN_ID
  run = gh_get(paste0("repos/", repo,"/actions/runs/",runid),pat)
  if (isTRUE(run$message == "Not Found")) {
    cat("\nRun not found.\n")
    return(NULL)
  }
  run
}

#' Get the id if the newest workflow run of a repo.
gh_newest_runid = function(repo, pat = gh_pat()) {
  runs = gh_list_runs(repo)
  runs$id[[1]]
}

#' Return all workflow runs
gh_list_runs = function(repo, pat=gh_pat()) {
  #https://api.github.com/repos/OWNER/REPO/actions/runs
  gh_get(paste0("repos/", repo,"/actions/runs"),pat)$workflow_runs

}

#' Return all workflows of the specified repo
gh_list_workflows = function(repo, pat = gh_pat()) {
  #https://api.github.com/repos/OWNER/REPO/actions/workflows
  gh_get(paste0("repos/", repo,"/actions/workflows"),pat)$workflows
}


#' Trigger the specified workflow
#'
#' Only works if the workflow YAML file sets
#'
#' on:
#'   workflow_dispatch:
#'
#' @param repo The repository name in format user/reponame.
#' @param name The name of the workflow. If NULL use the first workflow
#' @param branch The Github branch. By default "main"
#' @param inputs Not yet tested. Potential input parameters passed to the workflow.
#'
gh_run_workflow = function(repo,name=NULL,branch="main", inputs=NULL, pat = gh_pat()) {
  restore.point("gh_run_workflow")

  workflows = gh_list_workflows(repo, pat)

  if (NROW(workflows)==0) {
    cat("\nNo workflow found.")
    return(NULL)
  }

  row = 1
  if (!is.null(name)) {
    row = match(name, workflows$name)
  }

  wf_id = workflows$id[row]

  values = list(ref=branch)
  if (!is.null(inputs))
    values$inputs = inputs
  #https://api.github.com/repos/OWNER/REPO/actions/workflows/WORKFLOW_ID/dispatches \
  res = gh_post(paste0("repos/", repo,"/actions/workflows/",wf_id,"/dispatches"),values=values, pat = pat)

  res

}


#' Download an artifact generated by a finished job
gh_download_artifact = function(repo, destfile, artifact_id = NULL, runid=NULL, pat = gh_pat(), use_curl=FALSE) {
  restore.point("gh_download_artifact")

  if (is.null(artifact_id)) {
    artifacts = gh_list_artifacts(repo,runid=runid, pat)
    if (NROW(artifacts)==0) {
      cat("\nNo artifacts found.")
      return(NULL)
    }
    artifact_id = artifacts$id[[1]]
  }


  endpoint = paste0("repos/",repo,"/actions/artifacts/", artifact_id,"/zip")

  if (use_curl) {
    destfile = normalizePath(destfile, mustWork=FALSE)
    cmd = paste0('
curl --output ', destfile,' -L \\
  -H "Accept: application/vnd.github+json" \\
  -H "Authorization: Bearer ', pat,'" \\
  -H "X-GitHub-Api-Version: 2022-11-28" \\
  https://api.github.com/', endpoint)
    system(cmd)
  } else {
    res = gh_get(endpoint=endpoint,pat = pat, output="httr")
    if (res$status_code < 300) {
      writeBin(res$content, con = destfile)
      return(invisible(res))
    } else {
      msg = rawToChar(res$content)
      cat("\nCould not retrieve artifact.\n",msg)
      return(res)
    }
  }

}

#' List all artifacts of a repo

#' List all artifacts of a repo or single run
gh_list_artifacts = function(repo,runid=NULL, pat = gh_pat()) {
  if (is.null(runid)) {
    endpoint = paste0("repos/", repo,"/actions/artifacts")
  } else {
    # https://api.github.com/repos/OWNER/REPO/actions/runs/RUN_ID/artifacts
    endpoint = paste0("repos/", repo,"/actions/runs/",runid,"/artifacts")
  }
  res = gh_get(endpoint, pat)
  artifacts = res$artifacts
  artifacts
}


gh_put = function(endpoint, values=NULL, pat = Sys.getenv("GITHUB_PAT")) {
  restore.point("gh_put")
  headers = gh_headers(pat, add_content_type = TRUE)
  json.values = jsonlite::toJSON(values,auto_unbox = TRUE)

  httr::PUT(url = gh_url(endpoint), httr::add_headers(.headers=headers), body = json.values)
}

gh_post = function(endpoint, values, pat = Sys.getenv("GITHUB_PAT")) {
  restore.point("gh_post")
  headers = gh_headers(pat, add_content_type = TRUE)
  json.values = jsonlite::toJSON(values,auto_unbox = TRUE)

  httr::POST(url = gh_url(endpoint), httr::add_headers(.headers=headers), body = json.values)
}


gh_delete = function(endpoint, pat = Sys.getenv()) {
  restore.point("gh_delete")
  httr::DELETE(url = gh_url(endpoint), httr::add_headers(.headers=gh_headers(pat)))
}

gh_get = function(endpoint, pat=gh_pat(), output = c("json","text","org", "httr")[1]) {
  restore.point("gh_get")

  headers = gh_headers(pat, add_content_type = TRUE)
  res = httr::GET(url = gh_url(endpoint), httr::add_headers(.headers=headers))
  if (output == "httr" | output == "org") {
    return(res)
  }

  content = rawToChar(res$content)
  if (output == "text") return(content)
  jsonlite::fromJSON(content)

}


gh_url = function(endpoint) {
  paste0("https://api.github.com/", endpoint)
}

gh_headers = function(pat=Sys.getenv("GITHUB_PAT"), add_content_type=FALSE) {
  headers = c(
    `Accept` = 'application/vnd.github+json',
    `Authorization` = paste0("Bearer ", pat),
    `X-GitHub-Api-Version` = '2022-11-28'
  )
  if (add_content_type) {
    headers = c(headers,`Content-Type` = 'application/x-www-form-urlencoded')
  }
  headers
}
